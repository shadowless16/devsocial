import { type NextRequest, NextResponse } from "next/server";
import { connectWithRetry } from "@/lib/core/connect-with-retry";
import Post from "@/models/Post";
import User from "@/models/User";
import { getSession } from '@/lib/auth/server-auth';
import { errorResponse } from "@/utils/response";
import { awardXP, checkFirstTimeAction } from "@/utils/awardXP";
import UserStats from "@/models/UserStats";
import { checkReferralMiddleware } from "@/utils/check-referral-middleware";
import { processMentions } from "@/utils/mention-utils";
import { hashPost } from "@/lib/content/canonicalizer";
import { extractHashtags, findOrCreateTags } from "@/utils/tag-utils";
import Activity from '@/models/Activity'
import Like from '@/models/Like'
import mongoose from 'mongoose';

import { getWebSocketServer } from '@/lib/realtime/websocket'
import { cache } from '@/lib/core/cache'
import { mistralBackgroundService } from '@/lib/ai/mistral-background-service'

// Only import mission models if needed
let MissionProgress: typeof import("@/models/MissionProgress").default | null = null;

try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  MissionProgress = require("@/models/MissionProgress").default;
} catch {
  // MissionProgress model not available
}

export const dynamic = 'force-dynamic'
export const revalidate = 0 // Disable caching

//================================================================//
//  GET /api/posts - Fetch a feed of posts
//================================================================//
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const page = parseInt(searchParams.get("page") || "1", 10);
    const limit = parseInt(searchParams.get("limit") || "10", 10);
    const dataMode = searchParams.get("dataMode") as 'real' | 'generated' || 'real';
    const skip = (page - 1) * limit;

    // Check cache first for page 1 (most common request)
    const cacheKey = `posts_${page}_${limit}_${dataMode}`;
    if (page === 1) {
      const cached = cache.get(cacheKey);
      if (cached) {
        return NextResponse.json(cached);
      }
    }

    await connectWithRetry();

    // Get current user ID if authenticated
    let currentUserId = null;
    try {
      const session = await getSession(req);
      if (session?.user?.id) {
        currentUserId = session.user.id;
      }
    } catch {
      // Continue without authentication for public posts
    }

    // Build author filter based on dataMode (only filter if explicitly requested)
    // Note: Don't filter by isGenerated by default - users with DiceBear avatars are real users

    // Optimized aggregation query for better performance
    const posts = await Post.aggregate([
      { $match: { author: { $ne: null } } },
      { $sort: { createdAt: -1 } },
      { $skip: skip },
      { $limit: limit },
      {
        $lookup: {
          from: 'users',
          localField: 'author',
          foreignField: '_id',
          as: 'authorData'
        }
      },
      { $unwind: { path: '$authorData', preserveNullAndEmptyArrays: false } },
      {
        $project: {
          content: 1,
          tags: 1,
          imageUrl: 1,
          imageUrls: 1,
          videoUrls: 1,
          isAnonymous: 1,
          createdAt: 1,
          likesCount: 1,
          commentsCount: 1,
          viewsCount: 1,
          xpAwarded: 1,
          poll: 1,
          linkPreview: 1,
          author: {
            _id: '$authorData._id',
            username: '$authorData.username',
            firstName: '$authorData.firstName',
            lastName: '$authorData.lastName',
            avatar: '$authorData.avatar',
            level: '$authorData.level',
            role: '$authorData.role',
            gender: '$authorData.gender',
            displayName: '$authorData.displayName'
          }
        }
      }
    ])

    // Get user likes if authenticated - single optimized query
    let userLikes = new Set()
    if (currentUserId && posts.length > 0) {
      const postIds = posts.map(p => p._id)
      const likes = await Like.find({ 
        user: currentUserId, 
        targetId: { $in: postIds },
        targetType: 'post'
      }).select('targetId').lean()
      userLikes = new Set(likes.map(like => like.targetId.toString()))
    }

    // Transform posts
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const validPosts = posts.map((post: Record<string, unknown>) => ({
      ...post,
      id: post._id.toString(),
      author: post.author ? (() => {
        interface AuthorData {
          _id?: { toString: () => string };
          username: string;
          firstName?: string;
          lastName?: string;
          avatar?: string;
          level?: number;
          role?: string;
          gender?: string;
          displayName?: string;
        }
        const author = post.author as AuthorData;
        return {
          _id: author._id,
          username: author.username,
          firstName: author.firstName,
          lastName: author.lastName,
          avatar: author.avatar,
          level: author.level,
          role: author.role,
          gender: author.gender,
          id: author._id?.toString(),
          displayName: author.displayName || (author.firstName && author.lastName 
            ? `${author.firstName} ${author.lastName}` 
            : author.username),
        };
      })() : null,
      createdAt: new Date(post.createdAt as string | number | Date).toISOString(),
      tags: post.tags || [],
      viewsCount: post.viewsCount || 0,
      isLiked: currentUserId ? userLikes.has(post._id.toString()) : false,
    }));

    // Use count with filter for accuracy, but limit to reasonable number
    const totalPosts = dataMode === 'real' || dataMode === 'generated' 
      ? Math.min(await Post.countDocuments(), 10000) // Cap at 10k for performance
      : await Post.estimatedDocumentCount();

    const responseData = {
      success: true,
      data: {
        posts: validPosts,
        pagination: {
          currentPage: page,
          totalPages: Math.ceil(totalPosts / limit),
          totalPosts,
        },
      },
    };
    
    // Don't cache - always return fresh posts
    return NextResponse.json(responseData, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Posts API error';
    console.error('Posts API error:', errorMessage);
    // Return fallback data when database is unavailable
    const fallbackData = {
      success: true,
      data: {
        posts: [
          {
            id: 'demo1',
            content: 'Welcome to DevSocial! This is a demo post while the database is connecting.',
            author: { id: 'demo', username: 'demo', displayName: 'Demo User', avatar: '/placeholder.svg', level: 1 },
            tags: ['demo', 'welcome'],
            createdAt: new Date().toISOString(),
            likesCount: 5,
            commentsCount: 2,
            viewsCount: 10,
            isLiked: false
          }
        ],
        pagination: { currentPage: 1, totalPages: 1, totalPosts: 1 }
      }
    }
    return NextResponse.json(fallbackData);
  }
}

//================================================================//
//  POST /api/posts - Create a new post
//================================================================//
export async function POST(req: NextRequest) {
  try {
    const session = await getSession(req);
    if (!session?.user?.id) {
      return NextResponse.json(errorResponse('Authentication required'), { status: 401 });
    }

    let body;
    try {
      const rawBody = await req.text();
      
      if (!rawBody || rawBody.trim() === '') {
        return NextResponse.json(errorResponse("Request body is empty"), { status: 400 });
      }
      
      body = JSON.parse(rawBody);
    } catch {
      return NextResponse.json(errorResponse("Invalid JSON in request body"), { status: 400 });
    }
    
    const { content, tags, isAnonymous, imageUrl, imageUrls, videoUrls, poll } = body;
    const authorId = session.user.id;

    // Allow empty content if poll exists
    if ((!content || content.trim().length === 0) && !poll) {
      return NextResponse.json(errorResponse("Post content cannot be empty."), { status: 400 });
    }

    // Check content length limit with user-friendly message
    if (content.length > 2000) {
      const wordCount = content.split(/\s+/).length;
      return NextResponse.json(errorResponse(
        `Your post is too long! Please keep it under 2000 characters. Your post has ${content.length} characters (approximately ${wordCount} words). Try breaking it into multiple posts or removing some content.`
      ), { status: 400 });
    }

    await connectWithRetry();

    // Verify author exists
    const author = await User.findById(authorId);
    if (!author) {
      return errorResponse("Author not found.", 404);
    }

    // Extract hashtags from content
    const extractedHashtags = extractHashtags(content);
    const allTags = [...(tags || []), ...extractedHashtags];
    const uniqueTags = [...new Set(allTags)];

    // Create or find tags in database
    let tagIds = [];
    if (uniqueTags.length > 0) {
      tagIds = await findOrCreateTags(uniqueTags, authorId);
    }

    // Process mentions before creating post
    const { mentions, mentionIds } = await processMentions(content, '', authorId);

    const newPost = await Post.create({
      content: content || '',
      author: authorId,
      tags: uniqueTags,
      tagIds,
      mentions,
      mentionIds: mentionIds.map(id => new mongoose.Types.ObjectId(id)),
      imageUrl: imageUrl || null,
      imageUrls: imageUrls || [],
      videoUrls: videoUrls || [],
      isAnonymous: isAnonymous || false,
      viewsCount: 0,
      likesCount: 0,
      commentsCount: 0,
      poll: poll || null,
    });

    // Compute contentHash
    const contentHash = hashPost(newPost);
    await Post.findByIdAndUpdate(newPost._id, {
      contentHash
    });

    const populatedPost = await Post.findById(newPost._id)
      .populate("author", "username firstName lastName avatar level role gender displayName")
      .lean();

    if (!populatedPost) {
      return errorResponse("Failed to retrieve created post.", 500);
    }

    // Transform the post data to match frontend expectations
    interface PopulatedPostData {
      _id: { toString: () => string }
      author: {
        _id?: { toString: () => string }
        displayName?: string
        firstName?: string
        lastName?: string
        username: string
        gender?: string
      }
      createdAt: Date
      tags?: string[]
      likesCount?: number
      commentsCount?: number
      viewsCount?: number
      xpAwarded?: number
    }
    const postData = populatedPost as unknown as PopulatedPostData;
    const postAuthor = postData.author;
    const transformedPost = {
      ...postData,
      id: postData._id.toString(),
      author: postAuthor ? {
        ...postAuthor,
        id: postAuthor._id?.toString(),
        displayName: postAuthor.displayName || (postAuthor.firstName && postAuthor.lastName 
          ? `${postAuthor.firstName} ${postAuthor.lastName}` 
          : postAuthor.username),
        gender: postAuthor.gender,
      } : null,
      createdAt: new Date(postData.createdAt).toISOString(),
      tags: postData.tags || [],
      likesCount: postData.likesCount || 0,
      commentsCount: postData.commentsCount || 0,
      viewsCount: postData.viewsCount || 0,
      xpAwarded: postData.xpAwarded || 0,
    };

    // Update mentions with actual post ID
    if (mentions.length > 0) {
      await processMentions(content, newPost._id.toString(), authorId);
    }

    // Create an Activity record so the user's profile activity shows this post
    try {
      await Activity.create({
        user: new mongoose.Types.ObjectId(authorId),
        type: 'post_created',
        description: 'Created a new post',
        metadata: { postId: newPost._id.toString(), content },
        xpEarned: 0,
      })
    } catch {
      // Do not fail post creation if activity logging fails
    }

    // Check for daily hashtag bonus
    const dailyHashtags = {
      0: { hashtag: 'studysunday', xp: 75 }, // Sunday
      1: { hashtag: 'motivationmonday', xp: 50 }, // Monday
      2: { hashtag: 'tutorialtuesday', xp: 100 }, // Tuesday
      3: { hashtag: 'wipwednesday', xp: 60 }, // Wednesday
      4: { hashtag: 'throwbackthursday', xp: 40 }, // Thursday
      5: { hashtag: 'featurefriday', xp: 80 }, // Friday
      6: { hashtag: 'socialsaturday', xp: 30 }, // Saturday
    };
    
    const today = new Date().getDay();
    const todayChallenge = dailyHashtags[today as keyof typeof dailyHashtags];
    const hasDailyHashtag = uniqueTags.some(tag => 
      tag.toLowerCase().replace(/[^a-z0-9]/g, '') === todayChallenge.hashtag
    );

    // Mistral AI Quality Analysis (background task)
    let qualityBonus = 0;
    let qualityCategory = 'standard';
    if (content && content.trim().length > 50) {
      try {
        const analysis = await mistralBackgroundService.analyzeQuality(content);
        qualityBonus = analysis.xpBonus;
        qualityCategory = analysis.category;
        
        // Update post with quality metadata
        await Post.findByIdAndUpdate(newPost._id, {
          $set: {
            'metadata.aiQuality': {
              score: analysis.score,
              category: analysis.category,
              reasoning: analysis.reasoning,
              hasCode: analysis.hasCode,
              isEducational: analysis.isEducational,
              analyzedAt: new Date()
            }
          }
        });
      } catch {
        // Mistral quality analysis failed
      }
    }

    // Award XP for post creation
    const isFirstPost = await checkFirstTimeAction(authorId, "post");
    if (isFirstPost) {
      await awardXP(authorId, "first_post", newPost._id.toString());
    } else {
      const xpResult = await awardXP(authorId, "post_creation", newPost._id.toString());
      if (xpResult.limitReached) {
        console.log(`User ${authorId} reached daily post creation limit`);
      }
    }
    
    // Award quality bonus XP
    if (qualityBonus > 0) {
      await awardXP(authorId, "quality_content", newPost._id.toString(), qualityBonus);
      
      // Create activity for quality bonus
      await Activity.create({
        user: new mongoose.Types.ObjectId(authorId),
        type: 'quality_bonus',
        description: `Earned quality bonus: ${qualityCategory}`,
        metadata: { postId: newPost._id.toString(), category: qualityCategory, bonus: qualityBonus },
        xpEarned: qualityBonus,
      });
    }

    // Award bonus XP for daily hashtag participation
    if (hasDailyHashtag) {
      await awardXP(authorId, "daily_challenge", newPost._id.toString(), todayChallenge.xp);
    }

    // Update user stats
    await UserStats.findOneAndUpdate(
      { user: authorId },
      { 
        $inc: { totalPosts: 1 },
        $set: { lastActiveAt: new Date() }
      },
      { upsert: true }
    );

    // Check if this user has completed any referral requirements
    await checkReferralMiddleware(authorId);

    // Only track mission progress if user has explicitly joined missions
    if (MissionProgress) {
      try {
        const activeMissions = await MissionProgress.find({
          user: authorId,
          status: "active"
        }).populate('mission');

        for (const progress of activeMissions) {
          if (!progress.mission) continue;
          
          const mission = progress.mission;
          let progressUpdated = false;
          
          for (const step of (mission as any).steps || []) {
            const stepId = step.id || step._id?.toString();
            if (stepId && !progress.stepsCompleted.includes(stepId)) {
              // Check if this step is related to creating posts
              const stepText = ((step.title || '') + ' ' + (step.description || '')).toLowerCase();
              if (stepText.includes('post') && (stepText.includes('create') || stepText.includes('share') || stepText.includes('publish'))) {
                // Get current post count for user
                const userPostCount = await Post.countDocuments({ author: authorId });
                
                // Check if target is met
                if (userPostCount >= (step.target || 1)) {
                  progress.stepsCompleted.push(stepId);
                  progressUpdated = true;
                }
              }
            }
          }
          
          // Check if mission is completed
          if (progress.stepsCompleted.length >= ((mission as any).steps?.length || 0) && progress.status !== 'completed') {
            progress.status = "completed";
            progress.completedAt = new Date();
            progress.xpEarned = (mission as any).rewards?.xp || 0;
            progressUpdated = true;
          }
          
          if (progressUpdated) {
            await progress.save();
          }
        }
      } catch {
        // Don't fail the post creation if mission tracking fails
      }
    }

    // Send a lightweight notification to followers/author's sockets if available
    try {
      const wsServer = getWebSocketServer()
      if (wsServer) {
        wsServer.broadcast('post_created', {
          postId: newPost._id.toString(),
          authorId,
          content: content.substring(0, 200),
        })
      }
    } catch {
      // Failed to emit websocket post_created event
    }

    // No cache to invalidate anymore

    const responseData = {
      success: true,
      data: { post: transformedPost, message: "Post created successfully." }
    };
    
    return NextResponse.json(
      responseData,
      { status: 201 }
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Post creation error';
    console.error('Post creation error:', errorMessage);
    return NextResponse.json(errorResponse("Failed to create post due to a server error."), { status: 500 });
  }
}
