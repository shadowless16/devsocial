53f7e68fb80064c25552e9e000a4e944
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XP_VALUES = void 0;
exports.awardXP = awardXP;
exports.checkFirstTimeAction = checkFirstTimeAction;
const User_1 = __importDefault(require("@/models/User"));
const XPLog_1 = __importDefault(require("@/models/XPLog"));
const db_1 = __importDefault(require("@/lib/db"));
const referral_system_1 = require("./referral-system");
// XP values for different actions
exports.XP_VALUES = {
    daily_login: 10,
    post_creation: 20,
    comment_creation: 5,
    like_given: 2, // Small XP for likes to prevent spam
    like_received: 3, // Slightly more XP when receiving likes
    first_post: 50,
    first_comment: 25,
    poll_interaction: 5,
    badge_earned: 100,
    level_up: 200,
    moderator_action_bonus: 50,
    referral_success: 25, // XP for successful referral (referrer)
    referral_bonus: 15, // XP for being referred (new user)
    email_verified: 10,
    user_followed: 5,
    challenge_completion: 75,
};
function awardXP(userId, type, refId) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield (0, db_1.default)();
            const xpAmount = exports.XP_VALUES[type];
            if (!xpAmount) {
                throw new Error(`Invalid XP type: ${type}`);
            }
            // Create XP log entry
            yield XPLog_1.default.create({
                userId,
                type,
                xpAmount,
                refId: refId || undefined,
            });
            // Update user points
            const user = yield User_1.default.findById(userId);
            if (!user) {
                throw new Error("User not found");
            }
            const oldLevel = user.level;
            user.points += xpAmount;
            // Level will be automatically calculated in the pre-save hook
            yield user.save();
            const levelUp = user.level > oldLevel;
            // Award additional XP for leveling up
            if (levelUp) {
                yield XPLog_1.default.create({
                    userId,
                    type: "level_up",
                    xpAmount: exports.XP_VALUES.level_up,
                });
                user.points += exports.XP_VALUES.level_up;
                yield user.save();
            }
            // Check if this XP gain completes any pending referrals
            // Don't check for referral-related XP types to avoid infinite loops
            if (type !== "referral_success" && type !== "referral_bonus") {
                try {
                    yield referral_system_1.ReferralSystem.checkReferralCompletion(userId);
                }
                catch (error) {
                    console.error("Error checking referral completion:", error);
                    // Don't fail the XP award if referral check fails
                }
            }
            return {
                success: true,
                newLevel: user.level,
                levelUp,
            };
        }
        catch (error) {
            console.error("Error awarding XP:", error);
            return { success: false };
        }
    });
}
function checkFirstTimeAction(userId, type) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield (0, db_1.default)();
            const logType = type === "post" ? "post_creation" : "comment_creation";
            const existingLog = yield XPLog_1.default.findOne({ userId, type: logType });
            return !existingLog;
        }
        catch (error) {
            console.error("Error checking first time action:", error);
            return false;
        }
    });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxha2RhdlxcRG93bmxvYWRzXFxkZXZzb2NpYWxcXHV0aWxzXFxhd2FyZFhQLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSwwQkFtRUM7QUFFRCxvREFZQztBQTFHRCx5REFBZ0M7QUFDaEMsMkRBQWtDO0FBQ2xDLGtEQUFnQztBQUNoQyx1REFBa0Q7QUFFbEQsa0NBQWtDO0FBQ3JCLFFBQUEsU0FBUyxHQUFHO0lBQ3ZCLFdBQVcsRUFBRSxFQUFFO0lBQ2YsYUFBYSxFQUFFLEVBQUU7SUFDakIsZ0JBQWdCLEVBQUUsQ0FBQztJQUNuQixVQUFVLEVBQUUsQ0FBQyxFQUFHLHFDQUFxQztJQUNyRCxhQUFhLEVBQUUsQ0FBQyxFQUFHLHdDQUF3QztJQUMzRCxVQUFVLEVBQUUsRUFBRTtJQUNkLGFBQWEsRUFBRSxFQUFFO0lBQ2pCLGdCQUFnQixFQUFFLENBQUM7SUFDbkIsWUFBWSxFQUFFLEdBQUc7SUFDakIsUUFBUSxFQUFFLEdBQUc7SUFDYixzQkFBc0IsRUFBRSxFQUFFO0lBQzFCLGdCQUFnQixFQUFFLEVBQUUsRUFBRyx3Q0FBd0M7SUFDL0QsY0FBYyxFQUFFLEVBQUUsRUFBSyxtQ0FBbUM7SUFDMUQsY0FBYyxFQUFFLEVBQUU7SUFDbEIsYUFBYSxFQUFFLENBQUM7SUFDaEIsb0JBQW9CLEVBQUUsRUFBRTtDQUN6QixDQUFBO0FBRUQsU0FBc0IsT0FBTyxDQUMzQixNQUFjLEVBQ2QsSUFBNEIsRUFDNUIsS0FBYzs7UUFFZCxJQUFJLENBQUM7WUFDSCxNQUFNLElBQUEsWUFBUyxHQUFFLENBQUE7WUFFakIsTUFBTSxRQUFRLEdBQUcsaUJBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNoQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxFQUFFLENBQUMsQ0FBQTtZQUM3QyxDQUFDO1lBRUQsc0JBQXNCO1lBQ3RCLE1BQU0sZUFBSyxDQUFDLE1BQU0sQ0FBQztnQkFDakIsTUFBTTtnQkFDTixJQUFJO2dCQUNKLFFBQVE7Z0JBQ1IsS0FBSyxFQUFFLEtBQUssSUFBSSxTQUFTO2FBQzFCLENBQUMsQ0FBQTtZQUVGLHFCQUFxQjtZQUNyQixNQUFNLElBQUksR0FBRyxNQUFNLGNBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUE7WUFDeEMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtZQUNuQyxDQUFDO1lBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQTtZQUMzQixJQUFJLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQTtZQUV2Qiw4REFBOEQ7WUFDOUQsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUE7WUFFakIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUE7WUFFckMsc0NBQXNDO1lBQ3RDLElBQUksT0FBTyxFQUFFLENBQUM7Z0JBQ1osTUFBTSxlQUFLLENBQUMsTUFBTSxDQUFDO29CQUNqQixNQUFNO29CQUNOLElBQUksRUFBRSxVQUFVO29CQUNoQixRQUFRLEVBQUUsaUJBQVMsQ0FBQyxRQUFRO2lCQUM3QixDQUFDLENBQUE7Z0JBRUYsSUFBSSxDQUFDLE1BQU0sSUFBSSxpQkFBUyxDQUFDLFFBQVEsQ0FBQTtnQkFDakMsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUE7WUFDbkIsQ0FBQztZQUVELHdEQUF3RDtZQUN4RCxvRUFBb0U7WUFDcEUsSUFBSSxJQUFJLEtBQUssa0JBQWtCLElBQUksSUFBSSxLQUFLLGdCQUFnQixFQUFFLENBQUM7Z0JBQzdELElBQUksQ0FBQztvQkFDSCxNQUFNLGdDQUFjLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLENBQUE7Z0JBQ3RELENBQUM7Z0JBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztvQkFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHFDQUFxQyxFQUFFLEtBQUssQ0FBQyxDQUFBO29CQUMzRCxrREFBa0Q7Z0JBQ3BELENBQUM7WUFDSCxDQUFDO1lBRUQsT0FBTztnQkFDTCxPQUFPLEVBQUUsSUFBSTtnQkFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ3BCLE9BQU87YUFDUixDQUFBO1FBQ0gsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLG9CQUFvQixFQUFFLEtBQUssQ0FBQyxDQUFBO1lBQzFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUE7UUFDM0IsQ0FBQztJQUNILENBQUM7Q0FBQTtBQUVELFNBQXNCLG9CQUFvQixDQUFDLE1BQWMsRUFBRSxJQUF3Qjs7UUFDakYsSUFBSSxDQUFDO1lBQ0gsTUFBTSxJQUFBLFlBQVMsR0FBRSxDQUFBO1lBRWpCLE1BQU0sT0FBTyxHQUFHLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUE7WUFDdEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxlQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFBO1lBRWxFLE9BQU8sQ0FBQyxXQUFXLENBQUE7UUFDckIsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLG1DQUFtQyxFQUFFLEtBQUssQ0FBQyxDQUFBO1lBQ3pELE9BQU8sS0FBSyxDQUFBO1FBQ2QsQ0FBQztJQUNILENBQUM7Q0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFrZGF2XFxEb3dubG9hZHNcXGRldnNvY2lhbFxcdXRpbHNcXGF3YXJkWFAudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFVzZXIgZnJvbSBcIkAvbW9kZWxzL1VzZXJcIlxuaW1wb3J0IFhQTG9nIGZyb20gXCJAL21vZGVscy9YUExvZ1wiXG5pbXBvcnQgY29ubmVjdERCIGZyb20gXCJAL2xpYi9kYlwiXG5pbXBvcnQgeyBSZWZlcnJhbFN5c3RlbSB9IGZyb20gXCIuL3JlZmVycmFsLXN5c3RlbVwiXG5cbi8vIFhQIHZhbHVlcyBmb3IgZGlmZmVyZW50IGFjdGlvbnNcbmV4cG9ydCBjb25zdCBYUF9WQUxVRVMgPSB7XG4gIGRhaWx5X2xvZ2luOiAxMCxcbiAgcG9zdF9jcmVhdGlvbjogMjAsXG4gIGNvbW1lbnRfY3JlYXRpb246IDUsXG4gIGxpa2VfZ2l2ZW46IDIsICAvLyBTbWFsbCBYUCBmb3IgbGlrZXMgdG8gcHJldmVudCBzcGFtXG4gIGxpa2VfcmVjZWl2ZWQ6IDMsICAvLyBTbGlnaHRseSBtb3JlIFhQIHdoZW4gcmVjZWl2aW5nIGxpa2VzXG4gIGZpcnN0X3Bvc3Q6IDUwLFxuICBmaXJzdF9jb21tZW50OiAyNSxcbiAgcG9sbF9pbnRlcmFjdGlvbjogNSxcbiAgYmFkZ2VfZWFybmVkOiAxMDAsXG4gIGxldmVsX3VwOiAyMDAsXG4gIG1vZGVyYXRvcl9hY3Rpb25fYm9udXM6IDUwLFxuICByZWZlcnJhbF9zdWNjZXNzOiAyNSwgIC8vIFhQIGZvciBzdWNjZXNzZnVsIHJlZmVycmFsIChyZWZlcnJlcilcbiAgcmVmZXJyYWxfYm9udXM6IDE1LCAgICAvLyBYUCBmb3IgYmVpbmcgcmVmZXJyZWQgKG5ldyB1c2VyKVxuICBlbWFpbF92ZXJpZmllZDogMTAsXG4gIHVzZXJfZm9sbG93ZWQ6IDUsXG4gIGNoYWxsZW5nZV9jb21wbGV0aW9uOiA3NSxcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGF3YXJkWFAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0eXBlOiBrZXlvZiB0eXBlb2YgWFBfVkFMVUVTLFxuICByZWZJZD86IHN0cmluZyxcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBuZXdMZXZlbD86IG51bWJlcjsgbGV2ZWxVcD86IGJvb2xlYW4gfT4ge1xuICB0cnkge1xuICAgIGF3YWl0IGNvbm5lY3REQigpXG5cbiAgICBjb25zdCB4cEFtb3VudCA9IFhQX1ZBTFVFU1t0eXBlXVxuICAgIGlmICgheHBBbW91bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBYUCB0eXBlOiAke3R5cGV9YClcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgWFAgbG9nIGVudHJ5XG4gICAgYXdhaXQgWFBMb2cuY3JlYXRlKHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIHR5cGUsXG4gICAgICB4cEFtb3VudCxcbiAgICAgIHJlZklkOiByZWZJZCB8fCB1bmRlZmluZWQsXG4gICAgfSlcblxuICAgIC8vIFVwZGF0ZSB1c2VyIHBvaW50c1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmZpbmRCeUlkKHVzZXJJZClcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gICAgfVxuXG4gICAgY29uc3Qgb2xkTGV2ZWwgPSB1c2VyLmxldmVsXG4gICAgdXNlci5wb2ludHMgKz0geHBBbW91bnRcblxuICAgIC8vIExldmVsIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGluIHRoZSBwcmUtc2F2ZSBob29rXG4gICAgYXdhaXQgdXNlci5zYXZlKClcblxuICAgIGNvbnN0IGxldmVsVXAgPSB1c2VyLmxldmVsID4gb2xkTGV2ZWxcblxuICAgIC8vIEF3YXJkIGFkZGl0aW9uYWwgWFAgZm9yIGxldmVsaW5nIHVwXG4gICAgaWYgKGxldmVsVXApIHtcbiAgICAgIGF3YWl0IFhQTG9nLmNyZWF0ZSh7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgdHlwZTogXCJsZXZlbF91cFwiLFxuICAgICAgICB4cEFtb3VudDogWFBfVkFMVUVTLmxldmVsX3VwLFxuICAgICAgfSlcblxuICAgICAgdXNlci5wb2ludHMgKz0gWFBfVkFMVUVTLmxldmVsX3VwXG4gICAgICBhd2FpdCB1c2VyLnNhdmUoKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgWFAgZ2FpbiBjb21wbGV0ZXMgYW55IHBlbmRpbmcgcmVmZXJyYWxzXG4gICAgLy8gRG9uJ3QgY2hlY2sgZm9yIHJlZmVycmFsLXJlbGF0ZWQgWFAgdHlwZXMgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHNcbiAgICBpZiAodHlwZSAhPT0gXCJyZWZlcnJhbF9zdWNjZXNzXCIgJiYgdHlwZSAhPT0gXCJyZWZlcnJhbF9ib251c1wiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBSZWZlcnJhbFN5c3RlbS5jaGVja1JlZmVycmFsQ29tcGxldGlvbih1c2VySWQpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgcmVmZXJyYWwgY29tcGxldGlvbjpcIiwgZXJyb3IpXG4gICAgICAgIC8vIERvbid0IGZhaWwgdGhlIFhQIGF3YXJkIGlmIHJlZmVycmFsIGNoZWNrIGZhaWxzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBuZXdMZXZlbDogdXNlci5sZXZlbCxcbiAgICAgIGxldmVsVXAsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhd2FyZGluZyBYUDpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0ZpcnN0VGltZUFjdGlvbih1c2VySWQ6IHN0cmluZywgdHlwZTogXCJwb3N0XCIgfCBcImNvbW1lbnRcIik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGF3YWl0IGNvbm5lY3REQigpXG5cbiAgICBjb25zdCBsb2dUeXBlID0gdHlwZSA9PT0gXCJwb3N0XCIgPyBcInBvc3RfY3JlYXRpb25cIiA6IFwiY29tbWVudF9jcmVhdGlvblwiXG4gICAgY29uc3QgZXhpc3RpbmdMb2cgPSBhd2FpdCBYUExvZy5maW5kT25lKHsgdXNlcklkLCB0eXBlOiBsb2dUeXBlIH0pXG5cbiAgICByZXR1cm4gIWV4aXN0aW5nTG9nXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNoZWNraW5nIGZpcnN0IHRpbWUgYWN0aW9uOlwiLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9